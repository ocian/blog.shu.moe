{"pages":[{"title":"about","text":"可以叫我小树，我是一个 web 前端。Just a web front end developer, you can call me rubbish tree.","link":"/about/index.html"}],"posts":[{"title":"前端性能专题","text":"整理一下听过见过的性能问题。我的前端世界本来没多少性能问题，直到交流的多了，才知道原来可以有以下这么多的问题。 react 的性能隐患react 是一个单纯的 DOM 操作工具。如果 react 在一次或者多次更新过程中操作了过量的 DOM，有可能使得 web 界面不能及时被更新，这就会让用户直观的感受到卡顿。这个是 react 性能问题的根源。 react 的逻辑是开发者管控状态变化，状态变化触发 DOM 更新。所以提升性能的方向可以确定为： 只在必要的时候更新状态； 降低状态的更新频次。 如果能够落实这两点，react 的性能还是很不错的。React 提供了 useMemo 和 useCallback 来帮助控制状态的更新时机；在更新频率方面，可以用一次的所有状态更新，代替多次的逐个状态更新，这样做有助于降低状态更新过程中，协调 的运算量。 在使用 react 的前提下，性能是存在极限的，如果仍然达不到性能要求，就需要思考其他途径的解决办法了。我曾经遇到过一个上万条数据的列表渲染问题，他的特点是渲染时间很长，但是一个时间点的展示内容并不多。解决的方式比较取巧，首先模拟滚动框，保持内容高度，然后在滚动停止的时候计算出应该展示的内容，只渲染可以被用户看到的一小部分内容，隐藏所有其他的部分。这个通常被称为虚拟滚动，推荐使用 react-window。 再高的性能要求大概可以用 canvas 来满足。 浏览器加载性能web 的世界分为服务器和客户端两个部分，相互之间通过 http 协议来通信。浏览器就是大多数人的客户端，大家通过网址访问服务器的时候，浏览器就会帮忙获取内容，然后再呈现给用户。 提升浏览器的加载性能，可以尝试降低 URI 对应资源的大小，或者提高加载速度。 降低资源文件大小 首先是 js、css 类资源，在代码当中，换行和空格可以省略；js 的变量名，可以长的替换成短的，诸如此类。通常使用 tester, cssnano 等工具处理。 图片文件，可以通过压缩，显著降低图片的文件体积，同时不影响图片的展示效果。通常使用 image-webpack-loader 字体文件，可以通过 utf8 编码范围对字体文件进行拆分，比如 fontsource 的 noto-serif-sc","link":"/2021/07/11/front-end-performance-topic/"},{"title":"happy-js","text":"作为一个成熟的 JavaScript 工具人，应该学会面对超出预期的现象，理解产生麻烦的原因，整理合理不合情的情况，在反馈和反思中修改完善。 类型检查与拷贝JS 的数据类型可以大致分为两种，一种是值类型，引用值的变量之间不会产生相互影响；还有一种是引用类型，变量只保存引用，可能存在相互影响。接下来介绍一下两种类型： 12345678910111213// 值类型const a = 1; // a 的值是 1let b = a; // b 的值也是 1，a === bb = 2; // b 的值修改成了 2，a 的值还是 1，a !== bconst c = 1; // c 的值是 1，a === c// 引用类型const a = {a: 1}; // a 变量保存了 {a: 1} 的引用let b = a; // b 保存同样一份引用，两个变量 a 和 b 指向同一个对象值，b === ab = {a: 1}; // b 指向一个新声明的变量，对象变量之间的比较，比较引用的值是否是同一个，b !== aconst c = a; // a === cc.b = 2; // 通过变量 c 修改引用值a; // {a: 1, c: 2} 在这个前提之下，拷贝分为浅拷贝和深拷贝两种。直接获取一个变量的对象值引用，称为浅拷贝操作，会获得一个旧对象值的新引用，任何对旧对象值本身的操作，都会体现到对象值的所有引用变量上；通过旧对象值生成新对象值，称为深拷贝操作，会获得一个新对象值，对其修改不会对旧对象值产生影响。 1234567891011121314151617181920// 判断一个数据是否是数组function isArray(arr) { if (typeof Array.isArray === 'function') return Array.isArray(arr) else return {}.toString.call(arr) === '[object Array]'}// 深拷贝function deepClone(source) { // 如果是一个数组，针对数组中的每一项递归执行深拷贝 if (isArray(source)) return source.map((item) =&gt; deepClone(item)) // 如果是一个对象，针对每一个 key 的 value 递归 else if (typeof source === 'object' &amp;&amp; source !== null) { const target = {} for (let i in source) { target[i] = deepClone(source[i]) } return target } // 如果是其他数据类型，包含 null, undefined, number, string, boolean, bigint, symbol 不存在引用类型问题，可以直接返回 else return source} 日期格式化现代浏览器对日期时间操作的支持其实很完善，为体积考虑可以尽量避免 lodash 12345678910111213141516171819function timeFormat(timestamp, format = 'Y/M/D h:m:s') { const d = new Date(timestamp) if (d + '' === 'Invalid Date') return new Error('Invalid Date') const list = { Y: d.getFullYear(), M: d.getMonth() + 1, D: d.getDate(), h: d.getHours(), m: d.getMinutes(), s: d.getSeconds(), } return format.replace(/[Y|M|D|h|m|s]/g, (match) =&gt; (list[match] + '').padStart(2, '0') )}console.log(timeFormat(Date.now())) 符号表达式用在书写判断条件，或者执行顺序上面 123456+[] // 转换为 number 类型，[] 转换结果为 0''+[] // 转换为 string 类型，[] 转换结果为 ''!![] // 转换为 boolean 类型，[] 结果为 true~-1 // 按位非，~-1 结果为 0，我个人反应不过来这个true &amp;&amp; console.log('true') // &amp;&amp; 在第一个表达式 bool true 的情况下执行第二个表达式false || console.log('false') // || 在第一个表达式 bool false 的情况下执行第二个表达式 闭包变量是存在作用域的概念的，以函数作为边界，不可以越界访问。可以使用这个特性控制私有变量的访问方式。 12345678const [get, up, down] = (() =&gt; { let start = 0 return [ () =&gt; start, () =&gt; start += 1, () =&gt; start -= 1, ]})() thisTODO 循环没见过有人不会循环，这个算基础了吧 最简单的累计循环 123for (let i = 0; i &lt; 10; i += 1) { console.log(i)} 遍历对象 for in 遍历一个对象由于 for in 会获取原型链上面的属性，所以需要使用 hasOwnProperty 进行检查，或者使用 Object.create(null) 创建一个完全空的对象用于数据存储。 123456const list = {a: 1, b: 2, c: 3}for (const key in list) { if ({}.hasOwnProperty.call(list, key)) { console.log(key, list[key]) }} 使用 keys 方法遍历一个对象 Object.keys 12const list = {a: 1, b: 2, c: 3}Object.keys(list).map(key =&gt; { console.log(key, list[key]) }) for of 循环一个可迭代对象 1234const list = [1,2,3,4]for (const item of list) { console.log(item)} 遍历数组 map 数组遍历，这个方法有返回值 12const arr = Array.from({length: 3}) // 生成长度为 3 的数组arr.map((_, index) =&gt; index + 1) forEach 数组遍历，这个方法没有返回值 1[1,2,3].forEach(console.log) 字符串可以在字符串中，按照规则匹配相同类型的值 12345`?a=1&amp;b=2&amp;c=3`.replace(/[^\\?&amp;]*=[^\\?&amp;]*/g, match =&gt; { const arr = match.split('=') console.log(`key: ${arr[0]}, value: ${arr[1]}`) return ''}) 正则TODO","link":"/2021/07/11/happy-js/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"}],"categories":[]}